%% Le lingue utilizzate, che verranno passate come opzioni al pacchetto babel. Come sempre, l'ultima indicata sarà quella primaria.
%% Se si utilizzano una o più lingue diverse da "italian" o "english", leggere le istruzioni in fondo.
\def\thudbabelopt{english,italian}
%% Valori ammessi per target: bach (tesi triennale), mst (tesi magistrale), phd (tesi di dottorato).
%% Valori ammessi per aauheader: '' (vuoto -> nessun header Alpen Adria Univeristat), aics (Department of Artificial Intelligence and Cybersecurity), informatics (Department of Informatics Systems). Il nome del dipartimento è allineato con la versione inglese del logo UniUD.
%% Valori ammessi per style: '' (vuoto -> stile moderno), old (stile tradizionale).
\documentclass[target=bach,aauheader=,style=]{thud}

%% --- Informazioni sulla tesi ---
%% Per tutti i tipi di tesi
% Scommentare quello di interesse, o mettete quello che vi pare
\course{Informatica}
%\course{Internet of Things, Big Data e Web}
%\course{Matematica}
%\course{Comunicazione Multimediale e Tecnologie dell'Informazione}
\title{Un sistema distribuito per l'analisi della topologia di reti di calcolatori}
\author{Diego Cirillo}
\supervisor{Prof.\ Marino Miculan}
\cosupervisor{Dott.\ Matteo Paier}
%\tutor{Guido Necchi}
%% Campi obbligatori: \title, \author e \course.
%% Altri campi disponibili: \reviewer, \tutor, \chair, \date (anno accademico, calcolato in automatico), \rights
%% Con \supervisor, \cosupervisor, \reviewer e \tutor si possono indicare più nomi separati da \and.
%% Per le sole tesi di dottorato:
%\phdnumber{313}
%\cycle{XXVIII}
%\contacts{Via della Sintassi Astratta, 0/1\\65536 Gigatera --- Italia\\+39 0123 456789\\\texttt{http://www.example.com}\\\texttt{inbox@example.com}}

%% --- Pacchetti consigliati ---
%% pdfx: per generare il PDF/A per l'archiviazione. Necessario solo per la versione finale
\usepackage[a-1b]{pdfx}
%% hyperref: Regola le impostazioni della creazione del PDF... più tante altre cose. Ricordarsi di usare l'opzione pdfa.
\usepackage[pdfa]{hyperref}
%% tocbibind: Inserisce nell'indice anche la lista delle figure, la bibliografia, ecc.
\graphicspath{ {./images/} }
%% --- Stili di pagina disponibili (comando \pagestyle) ---
%% sfbig (predefinito): Apertura delle parti e dei capitoli col numero grande; titoli delle parti e dei capitoli e intestazioni di pagina in sans serif.
%% big: Come "sfbig", solo serif.
%% plain: Apertura delle parti e dei capitoli tradizionali di LaTeX; intestazioni di pagina come "big".
\usepackage{placeins}

\begin{document}
\maketitle

%% Dedica (opzionale)
%\begin{dedication}
%	Al mio cane,\par per avermi ascoltato mentre ripassavo le lezioni.
%\end{dedication}

%% Ringraziamenti (opzionali)
%\acknowledgements
%Sed vel lorem a arcu faucibus aliquet eu semper tortor. Aliquam dolor lacus, semper vitae ligula sed, blandit iaculis leo. Nam pharetra lobortis leo nec auctor. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Fusce ac risus pulvinar, congue eros non, interdum metus. Mauris tincidunt neque et aliquam imperdiet. Aenean ac tellus id nibh pellentesque pulvinar ut eu lacus. Proin tempor facilisis tortor, et hendrerit purus commodo laoreet. Quisque sed augue id ligula consectetur adipiscing. Vestibulum libero metus, lacinia ac vestibulum eu, varius non arcu. Nam et gravida velit.

%% Sommario (opzionale)
%\abstract
%La crescente complessità delle reti di calcolatori moderne richiede strumenti sofisticati per la loro analisi e gestione. Questa tesi presenta la progettazione e lo sviluppo di un sistema distribuito innovativo, capace di esplorare e mappare in modo efficiente le topologie di reti di grandi dimensioni. Il sistema proposto è in grado di estrarre informazioni significative sulla struttura della rete, identificando pattern, anomalie e potenziali vulnerabilità. L'obiettivo finale è fornire ai network administratori un quadro completo e dettagliato della loro infrastruttura, supportando decisioni informate e ottimizzando le performance della rete.

%% Indice
\tableofcontents

%% Lista delle tabelle (se presenti)
%\listoftables

%% Lista delle figure (se presenti)
%\listoffigures

%% Corpo principale del documento
\mainmatter

%% Parte
%% La suddivisione in parti è opzionale; solitamente sono sufficienti i capitoli.
%\part{Parte}

%% Capitolo
\chapter{Introduzione}
\section{Motivazioni dello Studio}
\subsection{Importanza dell'analisi della topologia di rete.}
Come descritto in \cite{tanenbaum2011computer} l'analisi della topologia di rete è un'attività cruciale per la gestione, la sicurezza e l'ottimizzazione delle infrastrutture di rete. La topologia di rete rappresenta la struttura fisica e logica di una rete, delineando come i dispositivi (come router, switch, server, ecc.) siano interconnessi e come i dati fluiscano tra di essi. Una comprensione dettagliata della topologia è essenziale per diverse ragioni:
\begin{itemize}
  \item Ottimizzazione delle Prestazioni: Una corretta analisi della topologia consente di identificare colli di bottiglia, percorsi inefficienti e configurazioni subottimali che possono influenzare negativamente le prestazioni della rete. Migliorando la topologia, si possono ottenere connessioni più rapide e una distribuzione del traffico più bilanciata.
  \item Gestione e Manutenzione: Conoscere la topologia della rete permette agli amministratori di pianificare meglio le operazioni di manutenzione, minimizzando i tempi di inattività e assicurando la continuità dei servizi. Inoltre, facilita la gestione delle risorse di rete, come l'allocazione degli indirizzi IP e la configurazione dei dispositivi.
  \item Sicurezza: L'analisi della topologia di rete è fondamentale per la sicurezza. Permette di identificare punti deboli nella struttura della rete, come collegamenti non protetti o dispositivi non autorizzati. Questo consente di implementare misure di sicurezza più efficaci, come firewall e segmentazioni di rete.
  \item Rilevamento e Risoluzione dei Problemi: In caso di problemi di rete, una mappa precisa della topologia aiuta a individuare rapidamente la causa dei malfunzionamenti, facilitando una risoluzione tempestiva e riducendo i tempi di inattività.
  \item Scalabilità: Una buona comprensione della topologia è essenziale quando si vuole espandere la rete. Aiuta a garantire che l'espansione avvenga in modo efficiente, senza compromettere le prestazioni o la sicurezza della rete.
\end{itemize}

\subsection{Scopi e obiettivi della tesi.}
La tesi ha come scopo principale la progettazione e lo sviluppo di un sistema distribuito innovativo per l'analisi della topologia di reti di calcolatori, che superi i limiti degli strumenti attualmente disponibili, come SNMP (Simple Network Management Protocol) \cite{rfc1157} e altri metodi tradizionali.
\newline
Obiettivi Specifici:
\begin{itemize}
  \item Identificazione delle Limitazioni degli Strumenti Esistenti:
    \begin{itemize}
      \item Analizzare i principali strumenti attualmente utilizzati per l'analisi della topologia di rete, evidenziando le loro carenze in termini di accuratezza, scalabilità, efficienza e sicurezza.
    \item Evidenziare in particolare i limiti di SNMP, come la sua dipendenza da dati statici, la mancanza di supporto per reti complesse e l'inefficienza nella gestione di grandi volumi di dati in tempo reale.
    \end{itemize}

  \item Progettazione di un'Architettura Distribuita:
    \begin{itemize}
      \item Sviluppare un'architettura di sistema distribuita che permetta un'analisi più accurata e dinamica della topologia di rete.
      \item Garantire che il sistema sia scalabile e in grado di gestire grandi reti eterogenee, mantenendo un basso impatto sulle risorse di rete.
    \end{itemize}
    
  %\item Sviluppo di Algoritmi Innovativi:
  %  \begin{itemize}
  %    \item Progettare e implementare algoritmi avanzati per il rilevamento e l'analisi della topologia, che siano in grado di adattarsi dinamicamente ai cambiamenti della rete.
  %    \item Migliorare l'efficienza del sistema, riducendo la latenza e ottimizzando l'uso delle risorse.
  %  \end{itemize}

  %\item Valutazione delle Prestazioni:
  %  \begin{itemize}
  %    \item Confrontare le prestazioni del sistema proposto con quelle degli strumenti esistenti, utilizzando criteri come accuratezza della mappatura, tempo di risposta, utilizzo delle risorse e sicurezza.
  %    \item Testare il sistema in diversi scenari reali per valutarne l'efficacia e identificare eventuali aree di miglioramento.
  %  \end{itemize}


  \item Contributo alla Comunità Scientifica e Industriale:
    \begin{itemize}
      \item Fornire una soluzione innovativa che possa essere utilizzata in ambito accademico e industriale per migliorare la gestione e la sicurezza delle reti di calcolatori.
      \item Contribuire alla letteratura esistente con nuove metodologie e strumenti per l'analisi della topologia di rete.
    \end{itemize}

\end{itemize}



\section{Struttura della Tesi}
\subsection{Breve panoramica dei capitoli successivi.}
Questa tesi è organizzata in x(!TODO) capitoli, ciascuno dei quali affronta aspetti fondamentali dello sviluppo e dell'analisi di un sistema distribuito per l'analisi della topologia di reti di calcolatori. Di seguito viene presentata una panoramica della struttura della tesi.

\begin{itemize}
  \item Capitolo 1: Introduzione
  \begin{itemize}
    \item[] Questo capitolo introduce il tema centrale della tesi, evidenziando l'importanza dell'analisi della topologia di rete. Vengono inoltre delineati gli scopi e gli obiettivi del lavoro, insieme alla struttura generale della tesi.
  \end{itemize}

  \item Capitolo 2: Stato dell'Arte
    \begin{itemize}
      \item[] Nel secondo capitolo vengono esaminati i concetti fondamentali di topologia di rete e vengono descritti i metodi comuni utilizzati per la sua analisi. Viene inoltre condotta un'analisi critica degli strumenti attualmente disponibili, con particolare attenzione ai loro limiti e alle carenze, soprattutto riguardo a SNMP.
    \end{itemize}

  \item    Capitolo 3: Soluzione Proposta
    \begin{itemize}
      \item[] In questo capitolo viene descritto il sistema proposto per l'analisi e la topologia di rete che vogliamo progettare evidenziando possibili vantaggi che altri strumenti come SNMP non possiedono.
    \end{itemize}

  \item Capitolo 4: Progettazione del Sistema
    \begin{itemize}
      \item[] Il quarto capitolo descrive in dettaglio l'architettura del sistema proposto, i protocolli di comunicazione utilizzati, gli algoritmi sviluppati per l'analisi della topologia e le misure di sicurezza adottate. Viene fornita una descrizione tecnica della progettazione del sistema, enfatizzando le soluzioni innovative implementate.
    \end{itemize}

  \item Capitolo 5: Implementazione
    \begin{itemize}
      \item[] In questo capitolo viene descritta l'implementazione pratica del sistema proposto. Viene esaminata la scelta delle tecnologie utilizzate, il processo di sviluppo del prototipo e i test effettuati per validare il sistema. Sono inoltre inclusi dettagli sull'integrazione delle diverse componenti.
    \end{itemize}

  \item Capitolo 6: Lavoro principale 
    \begin{itemize}
      \item[] Il sesto capitolo presenta una descrizione dei miei contributi specifici che ho apportato al progetto evidenziando come abbia affrontato varie sfide tecniche e collaborato con il team per migliorare l'architettura.
    \end{itemize}

  \item Capitolo 7: Conclusioni
    \begin{itemize}
      \item[] L'ultimo capitolo riflette sul mio percorso personale durante lo sviluppo del progetto sottolineando l'importanza della collaborazione e del lavoro di squadra nel raggiungimento dei risultati ottenuti. 
    \end{itemize}

\end{itemize}


\chapter{Stato dell'Arte}
\label{art}
\section{Analisi della Topologia di Rete}
\subsection{Metodi comuni di analisi della topologia.}
L'analisi della topologia di rete implica l'identificazione, la mappatura e la valutazione della struttura della rete, al fine di ottimizzarne il funzionamento e la gestione. Ecco i metodi più comuni utilizzati per questa analisi:
\subsubsection{SNMP (Simple Network Management Protocol) \cite{rfc1157}:}
    \begin{itemize}
      \item Descrizione: SNMP è un protocollo standardizzato per la gestione e il monitoraggio dei dispositivi di rete. Utilizzato per raccogliere informazioni sulla configurazione e lo stato dei dispositivi di rete, come router e switch.
      \item Vantaggi: Facilità d'uso, ampiamente supportato dai dispositivi di rete, consente di monitorare e gestire una vasta gamma di informazioni.
      \item Svantaggi: Limitato nella capacità di rilevare dinamicamente i cambiamenti nella topologia, difficoltà nell'analizzare reti complesse o eterogenee, problemi di scalabilità.
    \end{itemize}

\subsubsection{Traceroute \cite{netbrain_traceroute}:}
    \begin{itemize}
      \item Descrizione: Traceroute è uno strumento diagnostico che mostra il percorso che i pacchetti di dati seguono attraverso una rete IP verso una destinazione specifica, identificando tutti i router attraversati.
      \item Vantaggi: Utile per diagnosticare problemi di rete e identificare i percorsi dei dati tra dispositivi.
      \item Svantaggi: Limitato alle reti IP, non fornisce una visione completa della topologia, può essere bloccato da firewall o altri dispositivi di sicurezza.
    \end{itemize}

\subsubsection{NetFlow/IPFIX \cite{rfc7011}:}
    \begin{itemize}
      \item Descrizione: NetFlow (e la sua evoluzione IPFIX) è un protocollo sviluppato da Cisco per raccogliere informazioni sui flussi di dati che attraversano un router o uno switch. Fornisce dettagli sulle conversazioni di rete tra dispositivi.
      \item Vantaggi: Permette di monitorare il traffico di rete in dettaglio, utile per analisi del traffico e rilevamento di anomalie.
      \item Svantaggi: Non fornisce direttamente una mappa della topologia, ma piuttosto informazioni sui flussi di traffico, richiede una notevole capacità di elaborazione e archiviazione dei dati.
    \end{itemize}

\subsubsection{LLDP (Link Layer Discovery Protocol) \cite{ieee_lldp}:}
    \begin{itemize}
      \item Descrizione: LLDP è un protocollo di livello datalink utilizzato per scoprire dispositivi vicini e condividere informazioni sulla loro configurazione.
      \item Vantaggi: Consente la scoperta automatica dei dispositivi connessi alla rete e facilita la gestione della rete.
      \item Svantaggi: Limitato al livello 2 (livello di collegamento dati) della pila OSI, quindi non fornisce una visione completa della topologia a livello IP o superiore.
    \end{itemize}

\noindent Questi metodi offrono diverse prospettive sull'analisi della topologia di rete, ognuno con i propri punti di forza e debolezze. Tuttavia, nessuno di essi, preso singolarmente, offre una soluzione completa per l'analisi della topologia di reti complesse e dinamiche, evidenziando la necessità di strumenti più avanzati e integrati.

\subsection{Problemi dell'utilizzo di SNMP per l'Analisi della Topologia}
SNMP (Simple Network Management Protocol) è uno dei protocolli più utilizzati per il monitoraggio e la gestione delle reti, ma presenta diversi limiti significativi quando viene utilizzato per l'analisi della topologia di rete. Di seguito vengono analizzati i principali problemi associati all'uso di SNMP in questo contesto.
\begin{itemize}

  \item Scalabilità Limitata
    \begin{itemize}
      \item Overhead di Polling: SNMP si basa su un meccanismo di polling, in cui un sistema di gestione della rete (NMS) invia richieste ai dispositivi per ottenere informazioni sul loro stato. In una rete di grandi dimensioni, il numero di richieste necessarie per raccogliere i dati da tutti i dispositivi può diventare ingente, causando un significativo overhead di rete e aumentando il carico sui dispositivi stessi.
      \item Crescita Esponenziale del Traffico di Gestione: Man mano che il numero di dispositivi in rete aumenta, anche il volume del traffico di gestione generato da SNMP cresce esponenzialmente, rischiando di congestionare la rete e rallentare le operazioni di monitoraggio.
    \end{itemize}

  \item Visione Statica della Topologia
  \begin{itemize}
      \item Informazioni Non in Tempo Reale: Poiché SNMP si basa su un ciclo di polling, i dati raccolti rappresentano istantanee dello stato della rete in momenti specifici. Questo significa che i cambiamenti dinamici nella topologia, come l'aggiunta o la rimozione di dispositivi, potrebbero non essere rilevati immediatamente, portando a una rappresentazione obsoleta della rete.
      \item Mancanza di Rilevamento dei Cambiamenti Dinamici: In reti moderne, dove la topologia può cambiare rapidamente a causa della virtualizzazione, del cloud computing o delle configurazioni dinamiche, SNMP non riesce a rilevare e adattarsi efficacemente a questi cambiamenti.
  \end{itemize}


  \item Sicurezza Limitata
    \begin{itemize}
      \item Vulnerabilità di SNMPv1 e SNMPv2: Le prime versioni di SNMP (v1 e v2) non supportano meccanismi di sicurezza robusti, come l'autenticazione o la crittografia. Le informazioni vengono trasmesse in chiaro, rendendo la rete vulnerabile a intercettazioni e attacchi man-in-the-middle.
      \item Complessità di SNMPv3: Sebbene SNMPv3 introduca miglioramenti significativi in termini di sicurezza, includendo l'autenticazione e la crittografia, la sua implementazione è complessa e richiede una configurazione accurata per essere efficace. La complessità può scoraggiare la piena adozione o portare a configurazioni non sicure.
    \end{itemize}

  \item Complessità di Configurazione e Manutenzione
    \begin{itemize}
      \item Configurazione Manuale: Per ottenere una visione accurata della topologia, ogni dispositivo deve essere configurato per rispondere alle richieste SNMP, e questa configurazione deve essere mantenuta e aggiornata nel tempo. In grandi reti, questo può diventare un compito oneroso.
      \item Varianza di Supporto tra Vendor: Non tutti i dispositivi di rete supportano SNMP nello stesso modo, e le implementazioni possono variare tra i diversi vendor, portando a problemi di interoperabilità e difficoltà nel mantenere una mappa coerente della rete.
    \end{itemize}

  \item Limitata Capacità di Mappatura della Topologia
    \begin{itemize}
      \item Dati Limitati sulla Connettività: SNMP è utile per raccogliere dati su singoli dispositivi, come lo stato delle interfacce, l'uso della CPU o della memoria, ma non fornisce informazioni dettagliate sulle connessioni tra i dispositivi. Questo rende difficile ottenere una mappa completa e accurata della topologia della rete.
      \item Assenza di Informazioni di Layer 2: SNMP è principalmente focalizzato sui dati di Layer 3 (IP), mancando spesso le informazioni di Layer 2 (Ethernet), che sono cruciali per una mappatura dettagliata della topologia di rete, specialmente in ambienti complessi con VLAN e altri segmenti logici.
    \end{itemize}


  \item Problemi di Performance
    \begin{itemize}
      \item Impatto sulle Risorse del Dispositivo: L'elaborazione delle richieste SNMP può consumare risorse significative del dispositivo, specialmente su dispositivi con capacità hardware limitate. Questo può degradare le prestazioni del dispositivo stesso, influenzando la qualità del servizio di rete.
      \item Ritardi nella Raccolta dei Dati: In reti con molti dispositivi o con un utilizzo intensivo di SNMP, i ritardi nella raccolta e nell'analisi dei dati possono aumentare, rendendo meno tempestive le informazioni disponibili e, di conseguenza, meno utile l'analisi della topologia.
    \end{itemize}
\end{itemize}


\chapter{Progettazione del Sistema}

\section{Soluzione proposta}
Il sistema proposto per l'analisi della topologia di rete è basato su un'architettura distribuita che sfrutta un insieme di probes (sonde) per scansionare contemporaneamente diverse sezioni della rete. Ogni probe utilizza Nmap per raccogliere informazioni dettagliate, che vengono poi aggregate in un database centralizzato. Questo approccio consente di ottenere una visione completa e accurata della topologia di rete, superando i limiti di scalabilità e accuratezza degli strumenti tradizionali.

Nell'architettura proposta, i probes sono distribuiti strategicamente all'interno della rete, con ciascuno di essi responsabile di una specifica area. Operando simultaneamente, i probes eseguono scansioni parallele, raccogliendo dati sui dispositivi di rete, sulle connessioni e sui servizi attivi. I dati raccolti vengono inviati a un database centralizzato, dove vengono normalizzati e aggregati per creare una mappa coerente e dettagliata della rete. L'architettura include anche un sistema di visualizzazione interattivo che permette agli amministratori di esplorare la topologia in tempo reale, monitorando le modifiche e aggiornando continuamente le informazioni.

Uno dei principali vantaggi di questo sistema è la sua scalabilità. A differenza degli approcci centralizzati, che possono soffrire di colli di bottiglia man mano che la rete cresce, l'uso di probes distribuiti consente di gestire efficacemente anche le reti più estese. L'elaborazione parallela delle scansioni riduce il tempo necessario per mappare l'intera rete, distribuendo il carico di lavoro e prevenendo sovraccarichi sui singoli dispositivi.

Un altro vantaggio significativo riguarda l'accuratezza dei dati raccolti. Poiché ogni probe ha una visione dettagliata della porzione di rete che gli è assegnato, il sistema garantisce una copertura completa e precisa della topologia. Inoltre, il processo di aggregazione centralizzato consente di risolvere eventuali discrepanze nei dati e di eliminare le ridondanze, fornendo una rappresentazione accurata e aggiornata della rete.

L'architettura proposta offre anche maggiore resilienza rispetto ai sistemi tradizionali. Se uno o più probes dovessero fallire, il sistema può continuare a funzionare con i probes rimanenti, garantendo la continuità operativa. Inoltre, il sistema è altamente flessibile: può essere facilmente adattato per includere nuovi probes o per modificare l'area di scansione di quelle esistenti, rendendolo capace di rispondere rapidamente ai cambiamenti nella rete.

Dal punto di vista della sicurezza, il sistema è progettato per ridurre al minimo l'esposizione a potenziali attacchi. I dati raccolti vengono trasmessi al database centrale utilizzando canali sicuri e crittografati, proteggendo le informazioni sensibili da eventuali intercettazioni.

In sintesi, l'architettura distribuita proposta rappresenta un significativo miglioramento rispetto agli strumenti tradizionali di analisi della topologia di rete. Essa combina scalabilità, accuratezza, resilienza e sicurezza, offrendo una soluzione completa per la mappatura e il monitoraggio delle reti moderne.

\section{Architettura del Sistema}
\subsection{Descrizione dettagliata dell'architettura distribuita}
Il sistema è composto da una architettura client-server nella quale il backend si occupa di fare le scansioni, di salvarne i risultati e di fornirli al frontend dove possono essere visualizzati dagli utenti dovrebbero interagire solo con esso. 


\begin{figure}[h]
  \includegraphics[width=15cm, height=10cm]{client_server}
  \centering
\end{figure}

\FloatBarrier

Per organizzazione e scalabilità abbiamo diviso l'architettura in 6 moduli principali.


\begin{figure}[h]
  \includegraphics[width=15cm, height=10cm]{moduli_new}
  \centering
\end{figure}

\FloatBarrier

\subsubsection{Scan Probes}
Gli Scan Probes sono moduli che vengono collocati in giro per la rete a raccogliere informazioni. 
Ricevuto un comando il probe lo interpreta, esegue l'opportuna scansione e deserializza l'output dello scan.


\begin{figure}[h]
  \includegraphics[width=14cm, height=8cm]{probe}
  \centering
\end{figure}
\FloatBarrier


\subsubsection{Dispatcher} 
Il Dispatcher è il modulo che controlla e coordina le operazioni necessarie per le esecuzioni delle scansioni.
Riceve un comando dal Frontend che viene interpretato e mandato allo Scheduler che interagisce con l'Executer ed il Merger per eseguire la scansione e salvarla.

\begin{figure}[h]
  \includegraphics[width=14cm, height=8cm]{dispatcher}
  \centering
\end{figure}

\FloatBarrier

\subsubsection{Executer} 
L'Executer riceve un comando dallo Scheduler e coordina gli Scan Probes nell'esecuzione della scansione tramite un broker di messaggi idoneo. I risultati delle scansioni vengono poi salvati nel Network Knowledge Base.

\begin{figure}[h]
  \includegraphics[width=14cm, height=8cm]{executer}
  \centering
\end{figure}

\FloatBarrier

%/newpage

\subsubsection{Network Knowledge Base} 
Il Network Knowledge Base è la componente dove vengono salvati tutti i dati delle scansioni in modo persistente e che permette la visualizzazione di uno storico delle precedenti analisi.

\FloatBarrier

\subsubsection{Merger}
Il Merger si occupa di ricevere i dati generati dai Scan Probes ed amalgamarli per creare un'immagine comprensibile della rete analizzata. 


\begin{figure}[h]
  \includegraphics[width=14cm, height=8cm]{merger}
  \centering
\end{figure}

\FloatBarrier


\subsubsection{GUI} 
La GUI (Graphical User Interface) è un'interfaccia grafica che viene provvista a gli amministratori di rete per richiedere scansioni e visualizzarne i risultati.

\FloatBarrier

\chapter{In Dettaglio: Executer}
In questo capitolo viene descritto in dettaglio il funzionamento dell'executer che, come spiegato in breve nel capitolo prima, funge da componente centrale per la gestione della comunicazione e della supervisione delle attività all'interno di un sistema distribuito.


\begin{figure}[h]
  \includegraphics[width=14cm, height=8cm]{executer}
  \centering
\end{figure}

\FloatBarrier


\subsection{Dispatcher Communicator}
Il Dispatcher Communicator è il componente responsabile di ricevere comandi o dati dal modulo Dispatcher esterno. Il Dispatcher è un'entità centrale che invia istruzioni al Executer all'interno del sistema distribuito, fungendo da orchestratore. Il ruolo principale del Dispatcher Communicator è quello di stabilire una connessione stabile e affidabile con il Dispatcher e garantire che i messaggi inviati vengano processati correttamente. Una volta ricevuti i dati, il Dispatcher Communicator passa l'informazione al Supervisor per ulteriori azioni.
Oltre alla ricezione, il Dispatcher Communicator dovrebbe anche gestire l'eventuale feedback o risposta da inviare al Dispatcher, ad esempio conferme di esecuzione o report di stato. In scenari di reti distribuite su larga scala, il Dispatcher Communicator deve garantire che i messaggi siano consegnati anche in condizioni di rete congestionata o instabile. A tal fine, nell'implementazione  abbiamo utilizzando protocolli di rete affidabili come MQTT che verranno descritti nel capitolo successivo. L'efficacia di questo componente è cruciale per mantenere la sincronia e l'affidabilità del sistema, poiché è il punto di ingresso primario per le richieste di esecuzione di task.


\subsection{Supervisor}
Il Supervisor è il componente centrale dell'Executer che coordina e supervisiona l'esecuzione delle varie operazioni. Agisce come un gestore dei task, ricevendo input dal Dispatcher Communicator e determinando come e quando delegare i compiti agli altri moduli interni dell'Executer. Il Supervisor decide quali azioni intraprendere in base ai dati ricevuti e alle informazioni raccolte all'interno del sistema, interagendo costantemente con gli altri componenti come il Broker Communicator e il Collector.
Il Supervisor svolge un ruolo fondamentale nel garantire che le risorse vengano allocate correttamente e che i flussi di lavoro seguano un percorso ottimale. Può anche implementare logiche di fault-tolerance, monitorando lo stato delle varie parti del sistema e intervenendo in caso di malfunzionamenti. Inoltre, il Supervisor è responsabile di gestire la concorrenza tra task, assicurando che più operazioni possano essere eseguite in parallelo senza interferenze o colli di bottiglia. In un'architettura distribuita, il Supervisor deve essere altamente reattivo e scalabile, capace di orchestrare task in tempo reale e mantenere un alto grado di coerenza e integrità dei dati.

\subsection{Broker Communicator}
Il Broker Communicator gestisce la comunicazione tra l'Executer e un modulo esterno denominato Broker. Il Broker è un middleware che facilita lo scambio di messaggi tra i vari componenti di un sistema distribuito, e può utilizzare protocolli come MQTT, Kafka o altri sistemi di messaggistica. Il ruolo del Broker Communicator è quello di inviare e ricevere dati dal Broker, garantendo che i messaggi siano consegnati in modo affidabile e che le informazioni siano correttamente inoltrate tra i componenti del sistema.
Il Broker Communicator deve gestire più canali di comunicazione contemporaneamente, inviando messaggi a diversi destinatari e ricevendo dati da più fonti. In scenari di monitoraggio e analisi della rete. Una delle principali sfide affrontate dal Broker Communicator è garantire che i messaggi siano consegnati in maniera affidabile e senza perdita di dati, anche in ambienti di rete instabili. 

\subsection{Collector}
Il Collector è il componente che si occupa della raccolta e aggregazione dei dati all'interno del sistema. Riceve le informazioni dal Broker Communicator e la sua funzione principale è quella di raccogliere, filtrare e organizzare i dati che saranno poi utilizzati per aggiornare la Network Knowledge Base attraverso il Knowledge Base Connector.
Il Collector potrebbe avere la capacità di analizzare i dati raccolti in tempo reale, aggregarli, trasformarli in un formato standardizzato e fornire insight utili al Supervisor come il termine di una scansione. Inoltre, potrebbe essere responsabile della gestione delle metriche di performance e dello stato della rete. In sistemi di rete complessi, il Collector deve essere in grado di elaborare grandi quantità di dati in maniera efficiente, assicurandosi che la latenza sia ridotta al minimo. La sua scalabilità è critica in ambienti di rete di grandi dimensioni, poiché deve gestire un flusso continuo di dati provenienti da diverse fonti distribuite.

\subsection{Knowledge Base Connector}
l Knowledge Base Connector è il modulo che interfaccia l'Executer con una Network Knowledge Base esterna, il cui scopo è raccogliere e mantenere la conoscenza relativa alla topologia della rete, alle metriche di performance e ad altri dati critici. Questo componente funge da ponte tra il sistema distribuito e la base di conoscenza, permettendo al sistema di aggiornare continuamente il database con nuove informazioni ottenute dal Collector.
Il Knowledge Base Connector potrebbe inviare dati strutturati, come informazioni sui nodi e sui dispositivi della rete, configurazioni, e statistiche sulle performance, alla Knowledge Base. Per garantire l'affidabilità, potrebbe utilizzare protocolli di rete sicuri e meccanismi di autenticazione per proteggere i dati sensibili. In un sistema distribuito complesso, è essenziale che il Knowledge Base Connector garantisca l'accuratezza e la tempestività degli aggiornamenti, poiché la Knowledge Base funge da risorsa centrale per l'analisi della rete e la previsione di problemi futuri.

\chapter{Implementazione Executer}
\subsection{Supervisor}
Il Supervisor per poter eseguire il suo ruolo deve essere a conoscenza dei Probe funzionanti nel sistema, infatti quando un nuovo Probe si attiva manda un messaggio di registrazione contenente il suo Probe ID associato e il supervisor lo salva in una sua struttura dati interna. L'algoritmo di load balancing che è stato scelto per ora è un semplice Round Robin \cite{wiki:rr}, ovvero per ogni probe viene assegnato lo stesso tempo in un ordine circolare, ma in futuro avrà più senso aggiungere una priorità ai Probe che gestiscono una parte di rete più ampia in modo che tutti i Probe non finiscano in starvation.

\subsection{Broker Communicator}
Il Broker Communicator scambia i messaggi con Mosquitto, un Broker MQTT, in due modi:
\begin{itemize}
  \item L'Invio della scansione richiesta e ricevuta dal Supervisor incorporandola nel messaggi MQTT e pubblicandoli.
  \item La Ricezione è divisa in 3 tipi di messaggi:
    \begin{itemize}
      \item Register: notifica di iscrizione di un Probe.
      \item Result: i risultati di una scansione terminata da un Probe.
      \item Info: eventuali errori e altri dati relativi alle scansioni.
    \end{itemize}
\end{itemize}

\subsection{Collector}







\chapter{Implementazione del Sistema}
Per l'implementazione del sistema proposto, abbiamo scelto tecnologie moderne e performanti che garantiscono efficienza, scalabilità e una buona esperienza utente. Di seguito, descriviamo i principali strumenti e librerie utilizzati.

\begin{itemize}

  \item \subsubsection{Linguaggio di Programmazione e Librerie}
    L'intero core del sistema è stato sviluppato in Rust \cite{rust2024}, un linguaggio noto per le sue elevate prestazioni e sicurezza nella gestione della memoria. Rust è stato scelto per la sua capacità di gestire in modo efficiente operazioni parallele e concorrenti, essenziali per il funzionamento dei probes distribuiti. Le principali librerie utilizzate includono:
  \begin{itemize}
    \item[] Serde \cite{serde2024}: Utilizzata per la serializzazione e deserializzazione dei dati, facilitando la conversione tra strutture dati Rust e formati come JSON o YAML.
    \item[] Toki \cite{tokio2024}o: Un runtime asincrono che ci ha permesso di gestire in modo efficiente le operazioni I/O non bloccanti, fondamentali per il funzionamento simultaneo delle probes.
    \item[] Tracing \cite{tracing2024}: Utilizzata per la registrazione e il monitoraggio delle attività all'interno del sistema, fornendo strumenti per tracciare le prestazioni e diagnosticare problemi.
  \end{itemize}

\item \subsubsection{Scansione della Rete}
  Per la scansione della rete il sistema utilizza Nmap, uno strumento potente e versatile per la mappatura della topologia di rete. Nmap permette di identificare dispositivi di rete, porte aperte, servizi attivi e altre informazioni critiche necessarie per l'analisi della topologia. Le probes distribuite utilizzano Nmap per eseguire le scansioni in parallelo su diverse sezioni della rete.

\item \subsubsection{Interfaccia Grafica}
  Per lo sviluppo della GUI (Graphical User Interface), abbiamo utilizzato React \cite{react2024}, una libreria JavaScript particolarmente adatta per costruire interfacce utente interattive e dinamiche. L'uso di React ci ha permesso di sviluppare una GUI reattiva, in grado di visualizzare in tempo reale la topologia della rete e di offrire un'esperienza utente fluida.

\item \subsubsection{Applicazione Desktop}
  Abbiamo scelto Tauri \cite{tauri2024} come framework per l'implementazione dell'applicazione desktop. Tauri, combinato con React, ci ha permesso di creare un'applicazione leggera e performante, che offre la possibilità di distribuire il sistema come applicazione nativa su diverse piattaforme, mantenendo al contempo il codice base in JavaScript e Rust.

\item \subsubsection{Comunicazione tra Moduli}
  Per la comunicazione tra i diversi moduli del sistema, abbiamo implementato un sistema di messaggistica basato su MQTT \cite{mqtt2024}, utilizzando Mosquitto \cite{mosquitto2024} come broker. Mosquitto è un broker MQTT leggero e affidabile, ideale per gestire la comunicazione in tempo reale tra le probes distribuite, il backend e la GUI, garantendo una bassa latenza e una gestione efficiente dei messaggi.

\item \subsubsection{Gestione del Database}
  Per l'archiviazione e la gestione dei dati raccolti, abbiamo utilizzato PostgreSQL(!TODO ancora non abbiamo scelto). Questo sistema di gestione di database relazionale è stato scelto per la sua robustezza, scalabilità e capacità di gestire grandi volumi di dati in modo efficiente. PostgreSQL supporta anche funzionalità avanzate di analisi dei dati, che possono essere utili per elaborazioni future.

\item \subsubsection{Contenitori e Distribuzione}
  Infine, abbiamo adottato Docker \cite{docker2024} per la gestione delle istanze del database e del frontend. Docker ci ha permesso di isolare l'ambiente di esecuzione, garantendo che ogni componente del sistema funzioni in modo coerente su qualsiasi piattaforma. L'uso di Docker semplifica anche il processo di distribuzione e aggiornamento del sistema, facilitando l'integrazione continua e il deployment.

\end{itemize}



%% Capitolo
\chapter{Lavoro principale}
Nel corso dello sviluppo del sistema di analisi della topologia di rete, mi sono concentrato su diversi aspetti chiave dell'implementazione, contribuendo con soluzioni che hanno migliorato la leggibilità del codice, l'efficienza del sistema e la gestione dei dati. Di seguito, descrivo il lavoro che ho svolto.

\section{Miglioramento del Parser XML}
Inizialmente, il parser per i dati XML era implementato come una macchina a stati finiti. Questo approccio, sebbene funzionante, rendeva il codice complesso, difficile da leggere e da mantenere. Dopo un'analisi approfondita, ho suggerito di adottare un approccio di parsing incrementale utilizzando la libreria Serde.

Quando ho iniziato a lavorare su questo progetto, non avevo ancora una conoscenza approfondita di Rust. Ho provato a scrivere del codice per implementare il parser, ma non ha funzionato come previsto. Il codice per il parser finale è stato quindi scritto da un altro membro del team, ma la mia analisi e le mie raccomandazioni hanno guidato la transizione verso l'uso di Serde, migliorando significativamente la qualità del codice.

\section{Generazione di ID Unici per le Probes}
Ho scritto il codice per la generazione di un ID univoco per ciascuna probe, basato sul loro MAC address. Questo ID univoco è essenziale per identificare in modo preciso e inequivocabile ogni probe all'interno del sistema distribuito, garantendo la coerenza e l'integrità dei dati raccolti.

\section{Unit Testing e Risoluzione di Problemi nel Parser}
Mi sono occupato della scrittura degli unit test per il parser XML, con l'obiettivo di garantire che il nuovo approccio basato su Serde funzionasse correttamente in tutti i casi previsti. Durante la fase di testing, ho identificato alcuni problemi relativi alle strutture dati che avevamo creato per Serde. In particolare, ho rilevato incongruenze che avrebbero potuto compromettere l'efficacia del parsing. Grazie a questi test, siamo stati in grado di risolvere i problemi e di ottimizzare ulteriormente le strutture dati utilizzate.

\section{Modifica della Gestione del File di Configurazione}
Un'altra area su cui ho lavorato è stata la gestione del file di configurazione delle probes. Originariamente, questo file veniva creato nella directory in cui veniva eseguito il programma, una pratica che poteva causare confusione e problemi di gestione, soprattutto su sistemi multiutente. Ho modificato il codice affinché il file di configurazione venga ora creato in una directory standard di Linux per le configurazioni delle applicazioni: ~/.config/netstaldi/Config.toml. Questo cambiamento migliora la coerenza con le convenzioni di sistema e facilita la gestione delle configurazioni.

\section{Valutazione del Database Ottimale}
Attualmente sto contribuendo alla valutazione del database più adatto da utilizzare per l'archiviazione dei dati raccolti. Inizialmente, abbiamo considerato l'uso di ScyllaDB per il suo supporto integrato ai JSON, che sembrava promettente per le nostre esigenze. Tuttavia, ho scoperto che ScyllaDB non supporta i JSON nidificati, una limitazione che potrebbe ostacolare la nostra capacità di gestire dati complessi in futuro. Questa scoperta ha portato a riconsiderare le opzioni disponibili, e sto collaborando con il team per esplorare alternative più adatte alle nostre necessità.

%% Capitolo
%\chapter{Risultati}


%% Capitolo
\chapter{Conclusioni}
Questo progetto ha rappresentato per me una sfida entusiasmante e formativa, poiché è stata la prima volta che ho avuto l'opportunità di lavorare su un'iniziativa di media grandezza insieme ad altre persone. All'inizio, mi sentivo come se fossi in mare aperto, senza una chiara direzione e sopraffatto dalla complessità del lavoro. Il codice da scrivere, le tecnologie da apprendere e la necessità di collaborare efficacemente con il resto del team sembravano compiti immensi e difficili da gestire.

Tuttavia, grazie al sostegno e alla collaborazione degli altri membri del team, sono riuscito a superare queste difficoltà iniziali. Ho avuto l'opportunità di imparare moltissimo, sia dal punto di vista tecnico che umano. Le sfide che mi sembravano insormontabili sono diventate, grazie all'aiuto e alla guida dei miei colleghi, delle opportunità di crescita. La mia conoscenza di Rust è notevolmente migliorata, e ho acquisito una comprensione più profonda delle pratiche di sviluppo collaborativo e delle dinamiche di un progetto su larga scala.

Guardando al percorso che abbiamo compiuto finora, sono estremamente emozionato per come il progetto sta prendendo forma. La nostra architettura sta dimostrando di essere robusta e scalabile, e i miglioramenti che ho contribuito a implementare stanno avendo un impatto tangibile sulla qualità complessiva del sistema.

Ma non è solo il successo tecnico a motivarmi. Lavorare in un team che condivide la mia passione per la tecnologia e l'innovazione è stato incredibilmente gratificante. L'ambiente collaborativo e il continuo scambio di idee hanno reso questo progetto un'esperienza unica e preziosa per il mio sviluppo professionale e personale.

Per il futuro, sono determinato a continuare a contribuire a questo progetto. C'è ancora molto lavoro da fare, molte sfide da affrontare e molte opportunità di miglioramento e innovazione. Sono impaziente di vedere dove ci porterà questo viaggio e sono entusiasta di poter continuare a far parte del team che lo sta rendendo possibile.

In sintesi, questo progetto non è stato solo un'opportunità per applicare e sviluppare le mie competenze tecniche, ma è stato anche un'esperienza di crescita personale. La collaborazione, la condivisione delle conoscenze e il supporto reciproco sono stati elementi chiave per superare le difficoltà iniziali e portare avanti un lavoro di qualità. Sono grato per l'opportunità di far parte di questo team e sono entusiasta di continuare a contribuire al successo del progetto.

%%% Fine dei capitoli normali, inizio dei capitoli-appendice (opzionali)
%\appendix

%\part{Appendici}

%%\chapter{Titolo della prima appendice}
%Sed purus libero, vestibulum ut nibh vitae, mollis ultricies augue. Pellentesque velit libero, tempor sed pulvinar non, fermentum eu leo. Duis posuere eleifend nulla eget sagittis. Nam laoreet accumsan rutrum. Interdum et malesuada fames ac ante ipsum primis in faucibus. Curabitur eget libero quis leo porttitor vehicula eget nec odio. Proin euismod interdum ligula non ultricies. Maecenas sit amet accumsan sapien.

%% Parte conclusiva del documento; tipicamente per riassunto, bibliografia e/o indice analitico.
\backmatter

%% Riassunto (opzionale)
%\summary
%Maecenas tempor elit sed arcu commodo, dapibus sagittis leo egestas. Praesent at ultrices urna. Integer et nibh in augue mollis facilisis sit amet eget magna. Fusce at porttitor sapien. Phasellus imperdiet, felis et molestie vulputate, mauris sapien tincidunt justo, in lacinia velit nisi nec ipsum. Duis elementum pharetra lorem, ut pellentesque nulla congue et. Sed eu venenatis tellus, pharetra cursus felis. Sed et luctus nunc. Aenean commodo, neque a aliquam bibendum, mauris augue fringilla justo, et scelerisque odio mi sit amet diam. Nulla at placerat nibh, nec rutrum urna. Donec ut egestas magna. Aliquam erat volutpat. Phasellus vestibulum justo sed purus mattis, vitae lacinia magna viverra. Nulla rutrum diam dui, vel semper mi mattis ac. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Donec id vestibulum lectus, eget tristique est.

%% Bibliografia (praticamente obbligatoria)
\bibliographystyle{plain_\languagename}%% Carica l'omonimo file .bst, dove \languagename è la lingua attiva.
%% Nel caso in cui si usi un file .bib (consigliato)
\bibliography{thud}
%% Nel caso di bibliografia manuale, usare l'environment thebibliography.

%% Per l'indice analitico, usare il pacchetto makeidx (o analogo).

\end{document}

--- Istruzioni per l'aggiunta di nuove lingue ---
Per ogni nuova lingua utilizzata aggiungere nel preambolo il seguente spezzone:
    \addto\captionsitalian{%
        \def\abstractname{Sommario}%
        \def\acknowledgementsname{Ringraziamenti}%
        \def\authorcontactsname{Contatti dell'autore}%
        \def\candidatename{Candidato}%
        \def\chairname{Direttore}%
        \def\conclusionsname{Conclusioni}%
        \def\cosupervisorname{Co-relatore}%
        \def\cosupervisorsname{Co-relatori}%
        \def\cyclename{Ciclo}%
        \def\datename{Anno accademico}%
        \def\indexname{Indice analitico}%
        \def\institutecontactsname{Contatti dell'Istituto}%
        \def\introductionname{Introduzione}%
        \def\prefacename{Prefazione}%
        \def\reviewername{Controrelatore}%
        \def\reviewersname{Controrelatori}%
        %% Anno accademico
        \def\shortdatename{A.A.}%
        \def\summaryname{Riassunto}%
        \def\supervisorname{Relatore}%
        \def\supervisorsname{Relatori}%
        \def\thesisname{Tesi di \expandafter\ifcase\csname thud@target\endcsname Laurea\or Laurea Magistrale\or Dottorato\fi}%
        \def\tutorname{Tutor aziendale%
        \def\tutorsname{Tutor aziendali}%
    }
sostituendo a "italian" (nella 1a riga) il nome della lingua e traducendo le varie voci.
